### 搜索条件解析

功能就是将搜索字符串转换为中间格式,方便生成查询条件

### 使用场景描述

比如某个类sns的页面上提供一个搜索框,要查询zozoh这个用户,五月十号到七月二十号这段时间创建的信息

可以输入查询字符串 "@zozoh C[05.01,)"

分析下这个字符串,可以发现是通过空格作为多个条件的分隔符,每个条件是一个有意义的语句(或一个闭合空间)

"@zozoh" 即用户名等于zozoh

"C[05-10,07-20)" C代表"create time",[05-10,07-20)代表这个时间段(这里是包含五月十号,但不包含七月二十号,为什么请看符号"[]"与"()"的区别)


### 查询语句转换为中间结果

可以看到上面是一个比较有意思的查询语句, 我们可以把这种方式的查询应用在各个查询框中

同样我们也可以对其中的关键字做调整, 比如"@"代表端口号, "#"用来做分隔符等等, 这是是根据业务来定义的

不论上面的语句如何变化,我们都可以根据某个预定的规则,传转为一种通用的中间结果

中间结果的有以下规则:

1. 有两部分组成
	* 关键字, 例如@,大写字母C等等
	* 过滤条件, 除关键之外的都应该是条件
2. 多个查询条件默认是与(或)的关系
	* 空格(其他分隔符)和"&"代表关系"与"
	* "|" 代表关系或
	* 为了简便你可以设置全部是与或者全部是或
3. 为避免使用()来嵌套条件的问题,永远把前面的条件作为整体,依次进行与或操作
	* "a b" 代表 a 与 b
	* "a & b c" 代表 (a 与 b) 与 c
	* "a b | c" 代表 (a 与 b) 或 c
	* "a | b && c" 代表 (a 或 b) 与 c
	* 也就是说不允许嵌套, 要问为什么的话, 那是因为()的嵌套会导致分析字符串变复杂, 这种一个框里写查询的场景, 10%的需求才需要()嵌套, 所以可以先不考虑

基本上一个search的转换,有以下几个步骤:

1. 设置自己的条件准换规则
2. 根据准换规则解析查询字符串,生成一个类似链表结构的中间格式结果集
3. 将中间结果转换为底层查询支持的结构, 比如sql语句中的条件,mongodb的查询条件等等

### 中间结果集

中间结果
	
	{
		key : "user",
		cnd : "zozoh"	
	}
	
中间结果集

	// rels 是条件间的与或关系集合, 数量为cnds.length -1 
	// cnds 是条件的集合

	{
		rels : ["&"],
		cnds : [{
					key : "user",
					cnd : "zozoh"
				}, {
					key : "createTime",
					cnd : "[05-10,07-20)"
				}]
	}
	
	// 对于createTime这种区间过滤条件,也可以拆分成两个条件
	// 这个看具体使用场景来设置是否要拆分区间条件
	
	{
		rels : ["&", "&"],
		cnds : [{
					key : "user",
					cnd : "zozoh"
				}, {
					key : "createTime",
					cnd : ">= 05-10"
				}, {
					key : "createTime",
					cnd : "< 07-20"
				}]
	}
	
	// 有时候区间也代表一个特殊集合, 比如标签 #(餐饮,酒店) 或者 #(动态语言,函数式,闭包)
	// 看一个区间是代表区间还是代表集合看两点
	// 1.区间必须包含2项, 特殊集合可以是1-n项
	// 2.区间必须可以比较, 比如数字或时间等, 特殊集合可以无法比较
	
### 转换规则配置项

这个东西就像当你把一个对象序列化为json字符串时候需要一个json-format对象一样

字符串转中间结果集, 同样需要一个配置项来控制转换的细节

格式如下:

	{
		relMode 	: "any",  	// "any"代表支持与或, "and"全部为与, "or"全部为或
		splitBy 	: ",",    	// 相当于使用&, 代表与
		intervalOn	: true,		// 是否使用区间模式, 默认是打开, 关闭后区间条件会被解析为两条中间结果
		keyMap 		: {			// 关键字转换规则
						"@" : "user"
						"C" : "createTime" 
					},
		regexMap    : {         // 没有关键字的情况下, 搜索串符合某个正则表达式或等于某个特殊字符串, 代表某种业务逻辑
						"+.*" : function (str){ 
							return { // 包含指定域, 根据正则提取出+后面的内容,然后按照key,cnd填充中间结果
								key : "dmn",
								cnd : "has xxx"
							}
						},
						">>.*" : function (str) {
							// …….
						}
					}
	}

