### 搜索条件解析

功能就是将搜索字符串转换为中间格式,方便生成查询条件

### 使用场景描述

比如某个类sns的页面上提供一个搜索框,要查询zozoh这个用户,五月十号到七月二十号这段时间创建的信息

可以输入查询字符串 "@zozoh C[05.01,)"

分析下这个字符串,可以发现是通过空格作为多个条件的分隔符,每个条件是一个有意义的语句(或一个闭合空间)

"@zozoh" 即用户名等于zozoh

"C[05-10,07-20)" C代表"create time",[05-10,07-20)代表这个时间段(这里是包含五月十号,但不包含七月二十号,为什么请看符号"[]"与"()"的区别)


### 查询语句转换为中间结果

可以看到上面是一个比较有意思的查询语句, 我们可以把这种方式的查询应用在各个查询框中

同样我们也可以对其中的关键字做调整, 比如"@"代表端口号, "#"用来做分隔符等等, 这是是根据业务来定义的

不论上面的语句如何变化,我们都可以根据某个预定的规则,传转为一种通用的中间结果

中间结果的有以下规则:

1. 有两部分组成
	* 关键字, 例如@,大写字母C等等
	* 过滤条件, 除关键之外的都应该是条件
2. 多个查询条件默认是与(或)的关系
	* 空格(其他分隔符)和"&&"代表关系"与"
	* "||" 代表关系或
	* 为了简便你可以设置全部是与或者全部是或
3. 为避免使用()来嵌套条件的问题,永远把前面的条件作为整体,依次进行与或操作
	* "a b" 代表 a 与 b
	* "a b c" 代表 (a 与 b) 与 c
	* "a b || c" 代表 (a 与 b) 或 c
	* "a || b && c" 代表 (a 或 b) 与 c
	* 也就是说不允许嵌套, 要问为什么的话, 那是因为()的嵌套会导致分析字符串变复杂, 这种一个框里写查询的场景, 10%的需求才需要()嵌套, 所以可以先不考虑

基本上一个search的转换,有以下几个步骤:

1. 设置自己的条件准换规则
2. 根据准换规则解析查询字符串,生成一个类似链表结构的中间格式结果集
3. 将中间结果转换为底层查询支持的结构, 比如sql语句中的条件,mongodb的查询条件等等

### 中间结果集

PS:这里就以json格式来描述来

中间结果
	
	{
		key : "user",
		cnd : "zozoh"	
	}
	
中间结果集

	// rels 是条件间的与或关系集合, 数量为cnds.length -1 
	// cnds 是条件的集合

	{
		rels : ["&&"],
		cnds : [{
					key : "user",
					cnd : "zozoh"
				}, {
					key : "createTime",
					cnd : "[05-10,07-20)"
				}]
	}
	
	// 对于createTime这种区间过滤条件,也可以拆分成两个条件
	// 比如:
	
	{
		rels : ["&&", "&&"],
		cnds : [{
					key : "user",
					cnd : "zozoh"
				}, {
					key : "createTime",
					cnd : ">= 05-10"
				}, {
					key : "createTime",
					cnd : "< 07-20"
				}]
	}
	
	// 这个看具体使用场景来设置是否要拆分区间条件
	
### 转换规则配置项

这个东西就是你把一个对象序列化为json字符串时候需要一个json-format对象一样

字符串转中间结果集, 同样需要一个配置项

格式如下:

	

