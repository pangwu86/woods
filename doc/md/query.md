查询字符串解析
=======
> 让搜索框干更多的事情

## 为什么需要查询字符串的解析?

大多数 Web 应用，总会提供搜索框，而搜索框，由于被现在的搜索引擎们搞的，
让大家固执的认为就是随便输点内容就能搜索出结果

	My Logo                                                 Signup
	--------------------------------------------------------------
	
	
	                  I am a website
	               +--------------------+
	               |                    |  [Search]
	               +--------------------+

	--------------------------------------------------------------
       	                Copyright @ 2012

但是很多时候，作为程序员，我们不过是想开发出一个根据字段搜索的应用，而不是自己
构建复杂的全文检索机制。 为此，大家纷纷设计各种 **高级查询** 表单。 鉴于这些表单的五花八门
以及令人发指的复杂，我这里就不用 ASCII 画了。

首先我想达到的目的就是:

1. 仅仅通过一个输入框，就能得到界面传来字段查询信息
2. 用户输入的时候，不需写 JSON 等负责的格式化字符串

这样我在开发的时候就能你方便的调整后端代码。等一切搞定后，如果需要，再搞个令人发指的表单界面，
那这就是前端美工的事情了。同时，我也比较好做基于 HTTP 接口的测试

为此我决定接受输入框里输入一些特殊约定的字符，比如:

* "@xiaobai"，表示查询用户名为 "xiaobai" 的记录
* "C(2012-09-12,)"，表示查询创建时间为 2012-09-12 以后的记录
* …

我可以列很多的约定出来，但是如果让我每个项目都实现一遍，我又不肯，太麻烦。怎么才能做到一种抽象，
让很多项目稍微继承或者配置一下就能省却了解析这种特殊字符串的烦恼呢？

于是，@pangwu86 就提议了这个项目，而 query 这个功能就是我们提供的第一个通用功能

## 查询字符串的格式

为了能支持比较宽泛的查询字符串格式，我这里给个查询字符串的约定

	[AND|OR:] [字段约束] [分隔符] [字段约束] [分隔符] [字段约束]
	
也就是说

* 查询字符串是由一组约束条件构成的
	* 约束条件无非就是大于小于或等于某值
	* 或者，约束条件可以是一个枚举值序列
* 约束条件之间关系根据分隔符来界定
	* 默认的，空格 " " 表示约束之间用 **"或"** ，当然你可以给接口制定另外的几个字符
	* 默认的，逗号 "," 表示约束之间用 **"与"** ，当然你也可以给接口配置制定别的字符
	* 如果输入字符串开头以 "OR:" 开头，表示强制所有的约束为 **"或"**
	* 如果输入字符串开头以 "AND:" 开头，表示强制所有的约束为 **"与"**
	
同时，考虑到字段约束，可以写的比较自由，所以为了规避特殊字符，你可以把字段约束用引号引起来，
单引号或者双引号都成，比如

	^a.* , "age(10,)"       # 可以表示所有名字a开头并且年龄大于 10 岁的用户

## 你需要做什么

我们仅仅提供几种语言对于这种字符串的解析功能，会将其解析成一个列表。具体怎么理解这个列表是你的事情。
在解析之前你需要告诉我以下两种信息

1. 分隔符是什么？如果你不告诉我，我会把 `[+|,]` 这三个字符作为分隔符
2. 都有哪些字段? 你需要给我一个配置对象，描述你打算支持哪些约束？ 这个必须有
	3. 	你一定想知道怎么给我这个配置信息，请继续看 ...


## 如何描述字段约束信息

首先不同的语言都有对应的接口给你一个个的 add 这个约束信息。
你也可以把约束信息变成配置文件，直接通过字符串设置给我，一个约束信息就包含三个信息:

1. 正则表达式，表示是否匹配这个约束
2. 一个替换字符串模板，把内容从正则表达式分组里抽取出来
3. 一个类型，表示要把抽取出来的字符串理解成什么类型

比如上例:

                	^a.* , "age(10,)"
	
	# 要想理解上述两个约束字段，你需要提供下列配置项
	#-----------------------------------------------------
	# 针对 ^a.*
	# $ 开头的行，表示一个字段约束， $ 直到 : 直接的内容为键值
	# 冒号后面表示一个正则表达式，它的下一行给出了抽取模板和类型
	$name : ^([^].*)$
		${1}  = Regex
	#-----------------------------------------------------
	# 针对 age(10,0)
	$age : ^(age)([(\[]][0-9]*,?[0-9]*[)\])$
		${2}  = IntRegin
	#-----------------------------------------------------
	# 还可以写的再简单点，如果你对正则表达式不熟悉或者约束比较简单
	# 连续两个冒号表示简写模式
	$owner :: @     # 这个等价为 $owner : ^(@)(.*)$
		${2} = String
	#-----------------------------------------------------
	# 像 age 可以这样简写
	$age :: age      # 这个等价为 : ^(age)(.*)$
		${2} = IntRegin
		
我们现在支持下列约束类型
* Regex : 正则表达式
* String : 普通字符串
* IntRegion : 整数区间（可以支持开区间，闭区间，以及精确数值）
* LongRegion
* DateRegion
* StringEnum : 字符串枚举，每个枚举值请用半角逗号分隔开
* IntEnum : 整数枚举，每个枚举值请用半角逗号隔开
	
## 解析出来的是什么？

通过你提供的字段约束配置信息，我们能提供出一个解析后的中间结构, 下面是这个结构的 JSON 描述:

	{
		// 这个字段描述了各个条件之间的关系， 第一个表示
		// cnds[0] 与 cnds[1] 之间的关系
		rels : ["&", "&"],
		cnds : [{
				key    : "user",     // 约束的键值
				origin : "@zozoh",   // 约束的原始字符串
				plain  : "zozoh",    // 约束的原始值
				type   : "String",   // 字符串描述的类型
				value  : "zozoh",    // 解析后的值
			},{
				key    : "age",
				origin : "age(3,8]",
				plain  : "(3,8]",
				type   : "IntRegin",
				value  : {           // 不同语言都会提供一个 Region 对象描述一个范围
					left      : 3,
					leftOpen  : true,
					right     : 8,
					rightOpen : false
				}
			}, {
				key     : "name",
				orgigin : "^a.*$",
				plain   : "^a.*$",
				type    : "Regex",
				value   : /^a.*$/    // 不同语言原生的正则表达式对象
			}, {
				key     : "type",
				origin  : "T(3,8,10)",
				plain   : "3,8,10",
				type    : "IntEnum",
				value   : [3,8,10]   // 不同语言原始的数组对象
			}]
	}

## 各个语言的解析类

不同语言都会提供解析类

### Java

	QWordBuilder qb = new QWordBuilder(Files.find("~/myapp/mywords.conf"));
	qb.setup("{sepOr:'| +', sepAnd:',&'}");

	QWord qw = qb.parse("'age(4,10)', ^a.*");

### Golang

	qb := query.QWBuilder:
	qw := qb.parse("'age(4,10)', ^a.*");

### Js

	var conf = "$name : ^([^].*)$\n";
	conf += "…"
	…
	
	var qb = new QWordBuilder(conf);
	var qw = qb.parse("'age(4,10)', ^a.*");
	
### 各个语言都应该支持的接口函数

> 针对 golang 关于 public 方法很二很二的约定，大家自行将下面的函数首字母理解成大写的吧 ^_^!

**QWordBuilder**
	
	// 根据一个 Map 配置自己 
	setup({
        gOr     : 'OR',    // 为空则表示不支持全局的 "或"
        gAnd    : 'AND',   // 为空则表示不支持全局的 "与"
        sepOr   : '| +',   // 这个字符串每个字符都可以作为 "或" 的分隔符号 
        sepAnd  : ',&'     // 这个字符串每个字符都可以作为 "与" 的分隔符号 
	});
	
	// 执行解析，并准换成 QWord 对象
	QWord parse("xxxxx");
	
**QWord**
    
    QCnd[] cnds();       // 返回约束条件列表
    //-----------------------------------------------------------------------
    char[] rels();       // 返回每个约束条件直接的关系，可能是 '&' 或者 '|'
    //-----------------------------------------------------------------------
    bool   isAllAnd();   // 所有的约束条件是否是全 "与"
    bool   isAllOr();    // 所有的约束条件是否是全 "或"
    QWord  setAll('&');  // 设置所有的约束条件为 "与"，你如果传 '|' 就是 "或"
    //-----------------------------------------------------------------------
    int    size();       // 返回所有条件的数量
    bool   isEmpty();    // 是否木有任何一个条件
    //-----------------------------------------------------------------------
    // 这里提供迭代的回调
    each(func(index, QCnd, Bool){
        // index 为 0 base，表示迭代到第几个约束
        // QCnd 为约束本身
        // Bool 为这个约束与前一个约束的关系，如果 index == 0，则无意义
    });







